<!DOCTYPE html>

<html lang="en">

	<head>
		<title>Three.JS Skee-Ball</title>

		<link type="text/css" rel="stylesheet" href="main.css">

    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="../physi.js"></script>

    <script type="module">      
      Physijs.scripts.worker = '../physijs_worker.js';
      Physijs.scripts.ammo = 'files/js/ammo.js';
      import { GUI } from './jsm/libs/lil-gui.module.min.js';

      // Scene Variables
      var camera, light, scene, renderer, render;

      // Geometry Variables
      var boardAngle = Math.PI / 2.5, radius = 200, angle = 0;
      var ball, boardTop, boardBot, boardRamp, arrow, boxRight, boxLeft;

      // GUI Variables
      const gui = new GUI();
      var design, rampTranslateVal = 0;
      const params = {
        board: 0,
        trackLength: 0,
        moveBall: 0,
        rotateBall: 0
      };

      // Movement Variables
      var ballCenter = 0;
      var ballRotate = 0;
      var mouseStart = 0;
      var mouseEnd = 0;
      
      var inProgress = 0;
      var velocityInit = -2;
      var xvelocity, yvelocity, zvelocity;
				
      // Main function
			function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.getElementById( 'viewport' ).appendChild( renderer.domElement );
        
        // Creating the scene
        scene = new Physijs.Scene();
        scene.setGravity(new THREE.Vector3( 0, 0, 0 ));
        scene.addEventListener(
          'update',
          function() {
            scene.simulate( undefined, 1 );
          }
        );

        // Creating the camera
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 600;
				camera.position.y = 150;

        makeGeometries();
        makeGUI();

        // Event Listeners
				window.addEventListener( 'resize', onWindowResize );

				window.addEventListener( 'mousedown', function(event){
					mouseStart = event.clientY;
				});

				window.addEventListener( 'mouseup', function(event){
          if(!inProgress){
            // Checks that it's within a bounding box
            if (event.clientY < 545 && event.clientY > 350
            && event.clientX < 845 && event.clientX > 450){
              mouseEnd = event.clientY;
              inProgress = 1;
              scene.remove(arrow);

              // Enables gravity once the ball is released
              scene.setGravity(new THREE.Vector3( 0, -300, 0 ));

              // Sets the velocity dependent on mouse drag
              velocityInit = (mouseStart - mouseEnd) / 40;
              if (velocityInit < -5){
                velocityInit = -5;
              }
              else if (velocityInit > -2){
                velocityInit = -2;
              }
              ball.setLinearVelocity(new THREE.Vector3(0, velocityInit * -50, velocityInit * 80));

              // Hides GUI
              gui.close();
            }
          }
				});


        // Begins animation
        animate();
			}

      // Makes all geometries
      function makeGeometries(){
        // Variables
        let geometry, material;

        // Creating the board's top geometry
				geometry = new THREE.BoxGeometry( 220, 50, 400 );
				material = new THREE.MeshBasicMaterial( {color: 0x6CBB3C});

				let boardTopRect = new Physijs.BoxMesh( geometry, material, 0 );
        let boardTopEdge = new THREE.EdgesGeometry( geometry );
        let boardTopLine = new THREE.LineSegments( boardTopEdge, new THREE.LineBasicMaterial( { color: 0x000000 } ) );

        // Creating the board's bottom geometry
				geometry = new THREE.BoxGeometry( 220, 50, 400 );
				material = new THREE.MeshBasicMaterial( {color: 0x437C17});

				let boardBotRect = new Physijs.BoxMesh( geometry, material, 0 );
        let boardBotEdge = new THREE.EdgesGeometry( geometry );
        let boardBotLine = new THREE.LineSegments( boardBotEdge, new THREE.LineBasicMaterial( { color: 0x000000 } ) );

        // Creating the board's ramp
        geometry = new THREE.BoxGeometry( 220, 10, 50 );
				material = new THREE.MeshBasicMaterial( {color: 0x437C17});

				let boardRampRect = new Physijs.BoxMesh( geometry, material, 0 );
        let boardRampEdge = new THREE.EdgesGeometry( geometry );
        let boardRampLine = new THREE.LineSegments( boardRampEdge, new THREE.LineBasicMaterial( { color: 0x000000 } ) );

        // Grouping and adding the parts of the board to the scene
        boardTop = new THREE.Group();
        boardTop.add( boardTopRect );
        boardTop.add( boardTopLine );
        boardTop.rotation.x = boardAngle;
        boardTop.translateY(-100);
        boardTop.translateZ(-200);

        boardBot = new THREE.Group();
        boardBot.add( boardBotRect );
        boardBot.add( boardBotLine );
        boardBot.rotation.x = (Math.PI / 12);

        boardRamp = new THREE.Group();
        boardRamp.add( boardRampRect );
        boardRamp.add( boardRampLine );
        boardRamp.rotation.x = (Math.PI / 2.5);
        boardRamp.translateY(-50);
        boardRamp.translateZ(-84);

        let board = new THREE.Group();
        board.add( boardTop );
        board.add( boardBot );
        board.add( boardRamp );

        // Creating a box to contain the game
        geometry = new THREE.BoxGeometry( 450, 50, 550 );
        material = new THREE.MeshBasicMaterial( {color: 0x964B00});
    		boxRight = new Physijs.BoxMesh( geometry, material, 0 );
        boxLeft = new Physijs.BoxMesh( geometry, material, 0 );

        boxRight.rotation.z = (Math.PI / 2);
        boxRight.translateX(150);
        boxRight.translateY(-125);
        boxRight.translateZ(-50);

        boxLeft.rotation.z = (Math.PI / 2);
        boxLeft.translateX(150);
        boxLeft.translateY(125);
        boxLeft.translateZ(-50);

        // Adding a display to the box
        geometry = new THREE.BoxGeometry( 250, 40, 300 );
        material = new THREE.MeshBasicMaterial( {color: 0x362511});
        let boxDisplay = new Physijs.BoxMesh( geometry, material, 0 );

        boxDisplay.translateY(350);
        boxDisplay.translateZ(-100);

        let box = new THREE.Group();
        box.add( boxRight );
        box.add( boxLeft );
        box.add( boxDisplay );

        //Adding ball to the scene
        geometry = new THREE.SphereGeometry(15, 32, 16);
        material = new THREE.MeshBasicMaterial( { color:0xffffff } );
        ball = new Physijs.SphereMesh(geometry, material, 1);
        ball.translateY(10 - (Math.tan(Math.PI / 12)*200) + 30);		
        ball.translateZ(200);

        ball.addEventListener( 'collision', function( other_object, linear_velocity, angular_velocity ) {
            alert("COLLIDE")
        });
        
        //Add direction arrow
        geometry = new THREE.PlaneGeometry(10, 30);
        material = new THREE.MeshBasicMaterial( { color:0xff0000 } );
        let arrow1 = new Physijs.BoxMesh(geometry, material, 0);
        arrow1.translateZ(-25);
        arrow1.rotateX(-Math.PI/2);

        geometry = new THREE.PlaneGeometry(10, 30);
        material = new THREE.MeshBasicMaterial( { color:0xff0000 } );
        let arrow2 = new Physijs.BoxMesh(geometry, material, 0);
        arrow2.translateZ(25);
        arrow2.rotateX(-Math.PI/2);
        
        arrow = new THREE.Group();
        arrow.add( arrow1 );
        arrow.add( arrow2 );
        arrow.rotateX(Math.PI/12);
        arrow.translateY(40);
        arrow.translateZ(125);
		
        // The board difficulty is decided by where the points are
        makeBoard(0);

        // Adding everything to the scene
        scene.add( board );
        scene.add( box );
		    scene.add( ball );
	    	scene.add( arrow );
      }

      // Change Board
      function makeBoard(boardNum){
        if(design){
          scene.remove(design);
        }
        design = new THREE.Group();

        if (boardNum == 0){
          // Creating design for board 0
          design.add(makeCylinder(70, 0, 0)); // 20
          design.add(makePoints(0, 45));

          design.add(makeCylinder(20, 0, 5)); // 30
          design.add(makePoints(0, 5));

          design.add(makeCylinder(20, 0, -40)); // 40
          design.add(makePoints(0, -40));

          design.add(makeCylinder(20, 0, -100)); // 50
          design.add(makePoints(0, -100));

          design.add(makeCylinder(20, 65, -120)); // 100
          design.add(makePoints(65, -120));

          design.add(makeCylinder(20, -65, -120)); // 100
          design.add(makePoints(-65, -120));
        }

        else if (boardNum == 1){
          // Creating design for board 1
          design.add(makeCylinder(20, 0, -40)); // 20
          design.add(makePoints(0, -40));

          design.add(makeCylinder(20, 0, 25)); // 40
          design.add(makePoints(0, 25));

          design.add(makeCylinder(20, 0, -105)); // 40
          design.add(makePoints(0, -105));

          design.add(makeCylinder(20, 65, -40)); // 50
          design.add(makePoints(65, -40));
          
          design.add(makeCylinder(20, -65, -40)); // 50
          design.add(makePoints(-65, -40));
        }

        else if (boardNum == 2){
          // Creating design for board 2
          design.add(makeCylinder(20, 60, 35)); // 100
          design.add(makePoints(60, 35));

          design.add(makeCylinder(20, -60, 35)); // 100
          design.add(makePoints(-60, 35));

          design.add(makeCylinder(20, 60, -115)); // 100
          design.add(makePoints(60, -115));

          design.add(makeCylinder(20, -60, -115)); // 100
          design.add(makePoints(-60, -115));
        }

        scene.add( design );
	}

      // Makes the cylinders where the ball can score points
      function makeCylinder(outerRadius, x, y){
        // Creating cylinders
        var innerRadius = outerRadius - .1;
        var outerShape = new THREE.Shape();
        var holePath = new THREE.Path();
        
        // Makes a cylinder, then cuts a hole in it
        outerShape.absarc(x, y, outerRadius, 0, Math.PI * 2, false);
        holePath.absarc(x, y, innerRadius, 0, Math.PI * 2, true);
        outerShape.holes.push(holePath);

        let geometry = new THREE.ExtrudeGeometry(outerShape, {depth: 50});
        let material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
        let cylinder = new Physijs.CylinderMesh( geometry, material, 0 );

        // Rotates cylinder
        cylinder.translateY(-50);
        cylinder.rotation.x = ((Math.PI / 2) + boardAngle);
        cylinder.translateY(-250);
        cylinder.translateZ(10);

        return cylinder;
      }

      // Makes the points where the ball can score points by touching
      function makePoints(x, y){
        // Creating hole
        var outerShape = new THREE.Shape();
        outerShape.absarc(x, y, 19.9, 0, Math.PI * 2, false);

        let geometry = new THREE.ExtrudeGeometry(outerShape, {depth: 1});
        let material = new THREE.MeshBasicMaterial( {color: 0x000000} );
        let point = new Physijs.CylinderMesh( geometry, material, 0 );

        // Rotates the point
        point.translateY(-50);
        point.rotation.x = ((Math.PI / 2) + boardAngle);
        point.translateY(-250);
        
        // Pushes the hole against the board
        point.translateZ(59.7)

        return point;
      }

      // Makes the GUI
      function makeGUI(){
        // Updates the ramp's length, and box sides
        gui.add( params, 'board', 0, 2).step( 1 ).onChange( function ( value ) {
          makeBoard(value);
        } );

        gui.add( params, 'trackLength', -100, 100 ).step( 5 ).onChange( function ( value ) {
          boardBot.translateZ(value - rampTranslateVal);
          boxRight.translateZ(value - rampTranslateVal);
          boxLeft.translateZ(value - rampTranslateVal);
          camera.translateZ(value - rampTranslateVal);
          rampTranslateVal = value;
        } );

        //Moves the ball and arrow left to right
        gui.add( params, 'moveBall', -95, 95 ).step( 1 ).onChange( function ( value ) {
          if(!inProgress){
            ball.position.set(value, 10 - (Math.tan(Math.PI / 12)*200) + 30, 200);
            ballCenter = value;
            arrow.position.set(ballCenter, 40, 0);
            arrow.rotation.set(Math.PI/12, -ballRotate, 0);
            arrow.translateX(Math.sin(ballRotate)*200);
            arrow.translateZ((Math.cos(ballRotate)*200)-75);
          }
        } );

        //Sets ball launch angle
        gui.add( params, 'rotateBall', -90, 90 ).step( 1 ).onChange( function ( value ) {
          if (!inProgress){
            arrow.position.set(ballCenter, 40, 0);
            arrow.rotation.set(Math.PI/12, -Math.PI*value/180, 0);
            ballRotate = Math.PI*value/180;
            arrow.translateX(Math.sin(ballRotate)*200);
            arrow.translateZ((Math.cos(ballRotate)*200)-75);
          }
        } );
      }

      // Resize Window
      function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

      // Performs the animation
      function animate(){
        requestAnimationFrame( render );
		    scene.simulate();
      }

      // Renderer
      render = function() {
        renderer.render( scene, camera); // render the scene
        requestAnimationFrame( render ); 
      };

      window.onload = init;
		</script>
  </head>

  <body>
    <div id="viewport"></div>
  </body>
</html>
