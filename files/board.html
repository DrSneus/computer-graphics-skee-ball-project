<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { GUI } from './jsm/libs/lil-gui.module.min.js';

			var camera, scene, renderer;
      var boardAngle = Math.PI / 2.5;
      var radius = 200;
      var angle = 0;

      var rampTranslateVal = 0;
			const params = {
				trackLength: 0
			};

			init();
			animate();

      // Main function
			function init() {
        // Creating the camera and scene
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 600;
				camera.position.y += 150;

				scene = new THREE.Scene();

        // Variables
        let geometry, material;

        // Creating the board's top geometry
				geometry = new THREE.BoxGeometry( 220, 50, 400 );
				material = new THREE.MeshBasicMaterial( {color: 0x6CBB3C});

				let boardTopRect = new THREE.Mesh( geometry, material );
        let boardTopEdge = new THREE.EdgesGeometry( geometry );
        let boardTopLine = new THREE.LineSegments( boardTopEdge, new THREE.LineBasicMaterial( { color: 0x000000 } ) );

        // Creating the board's bottom geometry
				geometry = new THREE.BoxGeometry( 220, 50, 400 );
				material = new THREE.MeshBasicMaterial( {color: 0x437C17});

				let boardBotRect = new THREE.Mesh( geometry, material );
        let boardBotEdge = new THREE.EdgesGeometry( geometry );
        let boardBotLine = new THREE.LineSegments( boardBotEdge, new THREE.LineBasicMaterial( { color: 0x000000 } ) );

        // Creating the board's ramp
        geometry = new THREE.BoxGeometry( 220, 10, 50 );
				material = new THREE.MeshBasicMaterial( {color: 0x437C17});

				let boardRampRect = new THREE.Mesh( geometry, material );
        let boardRampEdge = new THREE.EdgesGeometry( geometry );
        let boardRampLine = new THREE.LineSegments( boardRampEdge, new THREE.LineBasicMaterial( { color: 0x000000 } ) );

        // Grouping and adding the parts of the board to the scene
        let boardTop = new THREE.Group();
        boardTop.add( boardTopRect );
        boardTop.add( boardTopLine );
        boardTop.rotation.x = boardAngle;
        boardTop.translateY(-100);
        boardTop.translateZ(-200);

        let boardBot = new THREE.Group();
        boardBot.add( boardBotRect );
        boardBot.add( boardBotLine );
        boardBot.rotation.x = (Math.PI / 12);

        let boardRamp = new THREE.Group();
        boardRamp.add( boardRampRect );
        boardRamp.add( boardRampLine );
        boardRamp.rotation.x = (Math.PI / 2.5);
        boardRamp.translateY(-50);
        boardRamp.translateZ(-84);

        let board = new THREE.Group();
        board.add( boardTop );
        board.add( boardBot );
        board.add( boardRamp );

        // Creating a box to contain the game
        geometry = new THREE.BoxGeometry( 450, 50, 550 );
        material = new THREE.MeshBasicMaterial( {color: 0x964B00});
				let boxRight = new THREE.Mesh( geometry, material );
        let boxLeft = new THREE.Mesh( geometry, material );

        boxRight.rotation.z = (Math.PI / 2);
        boxRight.translateX(150);
        boxRight.translateY(-125);
        boxRight.translateZ(-50);

        boxLeft.rotation.z = (Math.PI / 2);
        boxLeft.translateX(150);
        boxLeft.translateY(125);
        boxLeft.translateZ(-50);

        // Adding a display to the box
        geometry = new THREE.BoxGeometry( 250, 40, 100 );
        material = new THREE.MeshBasicMaterial( {color: 0x362511});
        let boxDisplay = new THREE.Mesh( geometry, material );

        boxDisplay.translateY(350);
        boxDisplay.translateZ(-50);

        let box = new THREE.Group();
        box.add( boxRight );
        box.add( boxLeft );
        box.add( boxDisplay );

        // Creating cylinders
        let cylinder20 = makeCylinder(70, 0, 0);
        let points20 = makePoints(0, 45);
        let cylinder30 = makeCylinder(20, 0, 5);
        let points30 = makePoints(0, 5);
        let cylinder40 = makeCylinder(20, 0, -40);
        let points40 = makePoints(0, -40);
        let cylinder50 = makeCylinder(20, 0, -100);
        let points50 = makePoints(0, -100);
        let cylinder100A = makeCylinder(20, 65, -120);
        let points100A = makePoints(65, -120);
        let cylinder100B = makeCylinder(20, -65, -120);
        let points100B = makePoints(-65, -120);

        // Adding everything to the scene
        scene.add( board );
        scene.add( cylinder20 );
        scene.add( points20 );
        scene.add( cylinder30 );
        scene.add( points30 );
        scene.add( cylinder40 );
        scene.add( points40 );
        scene.add( cylinder50 );
        scene.add( points50 );
        scene.add( cylinder100A );
        scene.add( points100A );
        scene.add( cylinder100B );
        scene.add( points100B );

        scene.add( box );

        // GUI
				const gui = new GUI();

        // Updates the ramp's length, and box sides
				gui.add( params, 'trackLength', -100, 100 ).step( 5 ).onChange( function ( value ) {
          boardBot.translateZ(value - rampTranslateVal);
          boxRight.translateZ(value - rampTranslateVal);
          boxLeft.translateZ(value - rampTranslateVal);
          camera.translateZ(value - rampTranslateVal);
          rampTranslateVal = value;
				} );

        // Rendering
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				// Event Listeners
				window.addEventListener( 'resize', onWindowResize );

			}

      // Resize Window
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

      // Makes the cylinders where the ball can score points
      function makeCylinder(outerRadius, x, y){
        // Creating cylinders
        var innerRadius = outerRadius - .1;
        var outerShape = new THREE.Shape();
        var holePath = new THREE.Path();
        
        // Makes a cylinder, then cuts a hole in it
        outerShape.absarc(x, y, outerRadius, 0, Math.PI * 2, false);
        holePath.absarc(x, y, innerRadius, 0, Math.PI * 2, true);
        outerShape.holes.push(holePath);

        let geometry = new THREE.ExtrudeGeometry(outerShape, {depth: 50});
        let material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
        let cylinder = new THREE.Mesh( geometry, material );

        // Rotates cylinder
        cylinder.translateY(-50);
        cylinder.rotation.x = ((Math.PI / 2) + boardAngle);
        cylinder.translateY(-250);
        cylinder.translateZ(10);

        return cylinder;
      }

      // Makes the points where the ball can score points by touching
      function makePoints(x, y){
        // Creating hole
        var outerShape = new THREE.Shape();
        outerShape.absarc(x, y, 19.9, 0, Math.PI * 2, false);

        let geometry = new THREE.ExtrudeGeometry(outerShape, {depth: 1});
        let material = new THREE.MeshBasicMaterial( {color: 0x000000} );
        let point = new THREE.Mesh( geometry, material );

        // Rotates the point
        point.translateY(-50);
        point.rotation.x = ((Math.PI / 2) + boardAngle);
        point.translateY(-250);
        
        // Pushes the hole against the board
        point.translateZ(59.7)

        return point;
      }

      // Animates
			function animate() {
				requestAnimationFrame( animate );
        
        // FOR TESTING: Rotating camera
        /*
        camera.rotation.y = -angle/2;
        camera.position.x = radius * Math.cos( angle );  
        camera.position.z = radius * Math.sin( angle );
        angle += 0.01;
        */
        
        // FOR TESTING: Sideways camera
        /*
        camera.rotation.y = -angle/2;
        camera.position.x = radius * Math.cos( angle );  
        camera.position.z = radius * Math.sin( angle );
        angle = 3.83;
        */
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>
